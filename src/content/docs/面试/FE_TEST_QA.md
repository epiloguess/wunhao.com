---
title: 2DM 前端工程师招聘笔试题
pubDate: 2023-09-15
description: ""
categories:
  - 前端
tags:
  - 面试
featured: false
draft: true
---

# 前端笔试题

### 2DM 前端工程师招聘笔试题。

- 选择题以及简答题和算法题在本文档作答后将文件发送给 HR 进行评分，
- 在编程题创建的 PR 中也提交本文档和所有所做的答案，并将文档命名为 `FE_TEST_QA.md`用于技术评分
- 编程题将会考察 git 和 github 的使用，需要通过 PR 进行提交

---

## 选择题

1. 下列哪个不是 JavaScript 的数据类型？ ( none )  
   A. String  
   B. Number  
   C. Boolean  
   D. Object

2. 下列哪个不是 CSS 的盒子模型？ ( D )  
   A. content-box  
   B. border-box  
   C. padding-box  
   D. margin-box

3. 下列哪个不是 Vue.js 的生命周期钩子函数？ ( D )  
   A. created  
   B. mounted  
   C. updated  
   D. destroyed

4. 下列哪个不是 HTTP 请求方法？ ( none )  
   A. GET  
   B. POST  
   C. PUT  
   D. DELETE

5. 下列哪个不是 HTML 标签？ ( D )  
   A. div  
   B. span  
   C. p  
   D. js

6. 下列哪个不是 CSS 选择器？ ( D )  
   A. .class  
   B. #id  
   C. :hover  
   D. @media

7. 下列哪个不是 JavaScript 的循环语句？ ( D )  
   A. for  
   B. while  
   C. do-while  
   D. if-else

8. 下列哪个不是 JavaScript 的比较运算符？ ( D )  
   A. ==  
   B. !=  
   C. ===  
   D. <=>

9. 下列哪个不是 JavaScript 的逻辑运算符？ ( D )  
   A. &&  
   B. ||  
   C. !  
   D. &

10. 下列哪个不是 JavaScript 的函数声明方式？ ( BCD )  
    A. function foo() {}  
    B. const foo = function() {}  
    C. const foo = () => {}  
    D. new Function('a', 'b', 'return a + b')

11. 下列哪个不是 JavaScript 的内置对象？ ( none )  
    A. Math  
    B. Date  
    C. Array  
    D. Promise

12. 下列哪个不是 JavaScript 的原始值？ ( none )  
    A. null  
    B. undefined  
    C. NaN  
    D. Infinity

13. 下列哪个不是 Vue.js 的指令？ ( C )  
    A. v-if  
    B. v-for  
    C. v-switch  
    D. v-bind

14. 下列哪个不是 CSS 的定位属性？ ( D )  
    A. position  
    B. top  
    C. left  
    D. width

15. 下列哪个不是 JavaScript 的错误类型？ ( D )  
    A. SyntaxError  
    B. TypeError  
    C. ReferenceError  
    D. RangeError

16. 下列哪个不是 Vue.js 的组件通信方式？ ( D )  
    A. props  
    B. event bus  
    C. Vuex  
    D. $emit

17. 下列哪个不是 JavaScript 的面向对象编程特性？ ( D )  
    A. 封装  
    B. 继承  
    C. 多态  
    D. 并发

18. 下列哪个不是 CSS 的动画属性？ ( C )  
    A. animation-name  
    B. animation-duration  
    C. animation-color  
    D. animation-timing-function

19. 下列哪个不是 JavaScript 的异步编程方式？ ( D )  
    A. 回调函数  
    B. Promise  
    C. async/await  
    D. for 循环

20. 下列哪个不是 Vue.js 的路由模式？ ( C )  
    A. hash  
    B. history  
    C. memory  
    D. abstract

21. 下列哪个不是 JavaScript 的事件类型？ ( B )  
    A. click  
    B. hover  
    C. keydown  
    D. scroll

22. 下列哪个不是 CSS 的布局方式？ ( C )  
    A. flexbox  
    B. grid  
    C. table  
    D. float

23. 下列哪个不是 JavaScript 的模块化规范？ ( D )  
    A. CommonJS  
    B. AMD  
    C. ES6 Module  
    D. jQuery

24. 下列哪个不是 Vue.js 的指令修饰符？ ( D )  
    A. .prevent  
    B. .stop  
    C. .once  
    D. .delay

25. 下列哪个不是 JavaScript 的数组方法？ ( none )  
    A. push  
    B. pop  
    C. shift  
    D. slice

26. 下列哪个不是 CSS 的字体属性？ ( C )  
    A. font-size  
    B. font-weight  
    C. font-color  
    D. font-family

27. 下列哪个不是 JavaScript 的定时器函数？ ( C )  
    A. setTimeout  
    B. setInterval  
    C. setImmediate  
    D. requestAnimationFrame

28. 下列哪个不是 Vue.js 的计算属性特性？ ( none )  
    A. 缓存  
    B. 响应式  
    C. 计算  
    D. 懒加载

29. 下列哪个不是 JavaScript 的正则表达式元字符？ ( C )  
    A. ^  
    B. $  
    C. &  
    D. \

30. 下列哪个不是 CSS 的背景属性？ ( none )  
    A. background-color  
    B. background-image  
    C. background-position  
    D. background-size

31. 下列哪个不是 JavaScript 的解构赋值方式？ ( none )  
    A. 数组解构  
    B. 对象解构  
    C. 函数解构  
    D. 字符串解构

32. 下列哪个不是 Vue.js 的过渡动画？ ( D )  
    A. v-enter  
    B. v-leave  
    C. v-move  
    D. v-fade

33. 下列哪个不是 JavaScript 的字符串方法？ ( D )  
    A. indexOf  
    B. split  
    C. join  
    D. push

34. 下列哪个不是 CSS 的边框属性？ ( none )  
    A. border-width  
    B. border-style  
    C. border-color  
    D. border-radius

35. 下列哪个不是 JavaScript 的面向对象编程语言？ ( none )  
    A. Java  
    B. Python  
    C. C++  
    D. Ruby

36. 下列哪个不是 Vue.js 的指令修饰符？ ( D )  
    A. .prevent  
    B. .stop  
    C. .once  
    D. .delay

37. 下列哪个不是 JavaScript 的全局对象？ ( none )  
    A. window  
    B. document  
    C. navigator  
    D. console

38. 当设置 box-sizing 为 content-box 时，下面关于 CSS 布局的描述，不正确的是？ ( BC )
    A. 块级元素实际占用的宽度与它的 width 属性有关  
    B. 块级元素实际占用的宽度与它的 border 属性有关  
    C. 块级元素实际占用的宽度与它的 padding 属性有关  
    D. 块级元素实际占用的宽度与它的 margin 属性有关

39. box-sizing 属性的默认值是什么？ ( A )
    A. content-box  
    B. border-box  
    C. padding-box  
    D. margin-box

40. 下列哪个属性不属于 CSS 的盒子模型？ ( D )  
    A. width  
    B. height  
    C. margin  
    D. color

---

## 简答题

#### - 请简述 Vue.js 的生命周期钩子函数？

每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。

#### - 请简述 Vue.js 的组件化开发方式？

Vue.js 的组件化开发方式是一种构建用户界面的方法，它将界面分解为小的、独立的可重用组件。这种方式有助于提高代码的可维护性、可读性和重用性，使开发更加高效。以下是 Vue.js 的组件化开发方式的主要特点和步骤：

1. **组件定义**：在 Vue.js 中，组件是由一个 Vue 实例构成的，它可以拥有自己的模板、数据、方法等。组件通常使用 `Vue.component` 方法来定义，或者使用 `.vue` 单文件组件的方式定义。
2. **组件复用**：组件可以被多次复用，这意味着你可以在不同的地方多次使用相同的组件，减少了重复编写相似代码的工作。
3. **组件通信**：组件之间可以通过 props（父子组件通信）和自定义事件（子父组件通信）进行通信。Props 允许父组件向子组件传递数据，而自定义事件允许子组件向父组件发送消息。
4. **局部作用域**：每个组件都拥有自己的作用域，不会污染全局命名空间。这意味着组件中定义的数据和方法只在组件内部有效，避免了命名冲突问题。
5. **单文件组件**：Vue.js 支持使用单文件组件（`.vue` 文件）的方式来组织组件相关的代码，包括模板、样式和逻辑，使代码更加清晰和可维护。
6. **生命周期钩子**：每个 Vue 组件都有一组生命周期钩子函数，可以在组件的不同阶段执行自定义逻辑，例如 `created`、`mounted`、`updated` 等。
7. **动态组件**：Vue 允许你使用动态组件来根据不同条件渲染不同的组件，这增强了组件的灵活性。
8. **全局组件和局部组件**：你可以将组件注册为全局组件，以便在任何地方使用，或者将组件注册为局部组件，仅在父组件中使用。
9. **路由与组件**：Vue.js 可以与路由库（例如 Vue Router）结合使用，实现基于路由的组件加载和页面切换。

总之，Vue.js 的组件化开发方式使前端开发更加模块化、可维护和可扩展，有助于构建复杂的用户界面并提高开发效率。

#### - 请简述 CSS 中的盒模型是什么，以及它的应用场景。

CSS 中的盒模型是一种用于描述 HTML 元素在网页布局中所占空间的模型。它将每个元素看作一个矩形盒子，这个盒子包括内容区域、内边距、边框和外边距四个部分。这些部分共同决定了元素在页面中的大小和定位。

盒模型的四个部分如下：

1. **内容区域（Content）**：这是元素实际包含内容的区域，例如文本、图片或其他子元素。内容区域的大小由 `width` 和 `height` 属性定义。
2. **内边距（Padding）**：内边距是内容区域与边框之间的空间，可以使用 `padding` 属性设置。内边距用来控制元素内容与边框之间的距离。
3. **边框（Border）**：边框是围绕内容和内边距的线条，可以使用 `border` 属性设置。边框可以有不同的样式、颜色和宽度，用于装饰和区分元素。
4. **外边距（Margin）**：外边距是边框与相邻元素之间的空间，可以使用 `margin` 属性设置。外边距用于控制元素与其周围元素的距离。

#### - 请简述 CSS 中的选择器有哪些，以及它们的优先级。

CSS 中有多种类型的选择器，用于选择页面中的元素以应用样式。这些选择器可以根据不同的规则和优先级来确定哪个样式将应用到元素上。以下是一些常见的 CSS 选择器以及它们的优先级：

1. **元素选择器**：通过元素的标签名称选择元素。例如，`p` 选择所有段落元素。
2. **类选择器**：通过元素的 `class` 属性选择元素。例如，`.my-class` 选择所有具有 `class` 属性值为 `my-class` 的元素。
3. **ID 选择器**：通过元素的 `id` 属性选择元素。例如，`#my-id` 选择具有 `id` 属性值为 `my-id` 的元素。
4. **后代选择器**：选择嵌套在其他元素内部的元素。例如，`ul li` 选择所有在 `ul` 元素内的 `li` 元素。
5. **子元素选择器**：选择作为另一个元素的直接子元素的元素。例如，`ul > li` 选择所有作为 `ul` 元素的直接子元素的 `li` 元素。
6. **相邻兄弟选择器**：选择与另一个元素具有相同父元素且紧跟在其后的元素。例如，`h2 + p` 选择紧跟在 `h2` 元素后的 `p` 元素。
7. **通用选择器**：选择页面上的所有元素。通用选择器用 `*` 表示。
8. **属性选择器**：选择具有特定属性或属性值的元素。例如，`[type="text"]` 选择所有具有 `type` 属性值为 "text" 的元素。
9. **伪类选择器**：选择元素的特定状态或位置，例如 `:hover` 用于鼠标悬停状态、`:nth-child` 用于选择特定位置的子元素等。

CSS 样式的优先级由以下几个因素决定，按照从高到低的顺序：

1. **重要性（!important）**：如果样式规则使用了 `!important` 标记，那么它将具有最高的优先级。
2. **内联样式**：在元素的 `style` 属性中直接指定的样式具有较高的优先级。
3. **ID 选择器**：具有 ID 选择器的样式规则优先级高于其他选择器。
4. **类选择器、属性选择器、伪类选择器**：这些选择器的优先级相等，较低于 ID 选择器。
5. **元素选择器**：元素选择器的优先级最低。
6. **特异性（Specificity）**：如果以上规则都没有决定胜出，那么根据选择器的特异性来决定。特异性是一个由四个部分组成的值，分别是 ID 选择器的数量、类选择器、属性选择器和伪类选择器的数量、元素选择器的数量。特异性值越高的规则优先级越高。
7. **规则的顺序**：如果以上所有规则仍然无法确定优先级，那么最后一条规则是根据它们在样式表中的顺序来决定的。后面的规则会覆盖前面的规则。

了解这些选择器和优先级规则有助于开发人员更好地控制样式应用于网页元素的方式，确保样式按预期进行应用。

#### - 请简述 CSS 中的浮动和清除浮动是什么，以及它们的应用场景。

在 CSS 中，浮动（float）和清除浮动（clear float）是用于控制元素在页面中定位和布局的两个关键概念。

**浮动（Float）：**

浮动是一种 CSS 属性，它允许元素向左或向右移动，直到它的边缘触及其容器的边缘或另一个浮动元素的边缘为止。浮动通常用于实现文本环绕图像、创建多列布局以及构建网页中的复杂布局结构。元素可以使用 `float: left;` 或 `float: right;` 来进行浮动。

**应用场景：**

1. **文本环绕图像**：浮动图像可以让文本环绕在图像的周围，使页面看起来更美观。
2. **多列布局**：浮动可以用于创建多列布局，使文本和元素能够在同一行上并排显示。
3. **网站导航**：浮动可以用于创建水平导航菜单，将链接水平排列在一行上。
4. **实现网页的响应式设计**：在响应式网页设计中，可以使用浮动来重新排列和调整元素的布局以适应不同的屏幕尺寸。

**清除浮动（Clear Float）：**

清除浮动是指在浮动元素下面插入一个元素，以防止浮动元素的影响扩散到后续元素。清除浮动通常通过 `clear` 属性来实现，可以将其应用于一个空元素或伪元素（如 `::after`）来清除前面的浮动元素。

**应用场景：**

1. **解决父元素高度坍塌问题**：当父元素包含浮动元素时，可能会出现高度坍塌的情况，父元素无法自动适应浮动元素的高度。通过在父元素末尾添加清除浮动的元素，可以解决这个问题。
2. **清除浮动以进行布局控制**：有时，浮动元素可能会使后续元素位置错乱，通过清除浮动，可以确保后续元素按照正常布局排列。

总之，浮动和清除浮动是 CSS 中用于布局控制的重要技术，但它们在现代网页设计中已经被更灵活的布局方法（如 Flexbox 和 Grid）所取代。在使用浮动和清除浮动时，需要小心处理，以确保页面的可维护性和稳定性。

#### - 请简述 CSS 中的定位和层叠顺序是什么，以及它们的应用场景。

在 CSS 中，定位（positioning）和层叠顺序（stacking order）是两个关键概念，用于控制元素的布局和在页面上的显示顺序。

**定位（Positioning）：**

定位是一种 CSS 属性，用于控制元素在文档流中的位置。常见的定位属性有 `position`，可以设置为以下几个值：

1. `static`（默认值）：元素按照正常文档流进行布局，忽略 `top`、`right`、`bottom` 和 `left` 属性。
2. `relative`：元素的位置相对于它在正常文档流中的位置进行偏移，但不会影响其他元素的布局。
3. `absolute`：元素的位置相对于最近的已定位祖先元素（通常是具有 `position: relative;` 或 `position: absolute;` 的元素）进行定位。
4. `fixed`：元素的位置相对于浏览器窗口进行定位，元素会固定在屏幕上，不随页面滚动而移动。

**应用场景：**

- `relative` 定位常用于微调元素的位置，可以使元素相对于自己在正常文档流中的位置产生偏移。
- `absolute` 定位常用于创建浮动菜单、弹出框等需要相对于特定父元素进行定位的情况。
- `fixed` 定位用于创建固定在页面某个位置的元素，例如固定导航栏、广告悬浮框等。

**层叠顺序（Stacking Order）：**

层叠顺序是指在页面上重叠的元素之间的显示顺序。它由 CSS 的层叠上下文、层叠层级和层叠顺序属性共同决定。层叠顺序属性包括 `z-index`，它用于定义元素的层叠顺序。

**应用场景：**

- 使用 `z-index` 属性可以控制元素在重叠情况下的显示顺序，将某个元素放在其他元素的前面或后面。
- 层叠顺序常用于创建页面中的弹出框、模态框、导航菜单等组件，以确保它们显示在其他内容之上。

总之，定位和层叠顺序是 CSS 中用于控制元素布局和显示顺序的重要概念。它们在创建复杂的页面布局和用户界面组件时非常有用，但需要小心使用，以避免不必要的布局问题和层叠冲突。

#### - 请简述 CSS 中的响应式设计是什么，以及它的应用场景。

CSS 中的响应式设计是一种通过使用不同的 CSS 技术和布局策略，使网页能够适应不同设备、屏幕尺寸和分辨率的方法。它的目标是确保网页在各种环境下都能提供最佳的用户体验，无论用户是在桌面电脑、平板电脑、手机或其他设备上访问网页。

响应式设计的主要特点和应用场景包括：

1. **流动布局**：响应式设计使用流动布局，元素的宽度相对于父容器而不是固定的像素值，这使得页面能够适应不同的屏幕宽度。
2. **媒体查询**：媒体查询是 CSS3 中的功能，它允许根据设备特性（如屏幕宽度、设备类型等）应用不同的 CSS 样式。这使得可以为不同的设备定义不同的布局和样式。
3. **弹性图像和媒体**：响应式设计使用弹性图像和媒体（例如，使用 `max-width: 100%;`）来确保它们在各种屏幕尺寸下不会变形或溢出。
4. **断点**：响应式设计通常在不同的屏幕宽度断点上重新布局页面。这些断点可以通过媒体查询定义，例如，在小屏幕上采用一种布局，而在大屏幕上采用另一种布局。
5. **隐藏或显示内容**：在较小的屏幕上，可能需要隐藏某些内容或将其转换为折叠菜单，以确保页面仍然易于浏览。
6. **优化性能**：响应式设计通常包括性能优化，例如加载适合当前设备分辨率的图像，以减少页面加载时间。
7. **测试和调试**：响应式设计需要在多个设备和分辨率下进行测试和调试，以确保页面在各种情况下正常工作。
8. **适应未来设备**：响应式设计的目标是能够适应未来的各种设备和屏幕尺寸，而不仅仅是当前的设备。

响应式设计的主要优点是提供了更好的用户体验，减少了维护不同版本网页的工作量，并使网站能够在各种设备上保持一致的品牌和外观。响应式设计已经成为现代网页开发的标准实践，可以确保网页在不同设备上都能够良好地运行。

## 算法题

- 请实现一个二分查找算法。

  ```javascript
  function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (arr[mid] === target) {
            return mid; // 找到目标元素，返回它的索引
        } else if (arr[mid] < target) {
            left = mid + 1; // 目标在右半部分，更新左边界
        } else {
            right = mid - 1; // 目标在左半部分，更新右边界
        }
    }


  ```

- 请实现一个链表的反转算法。

  ```javascript
  class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
  }
  class LinkedList {
    constructor() {
        this.head = null;
    }
    // 向链表尾部添加节点
    append(data) {
        const newNode = new Node(data);
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
    }
    // 反转链表
    reverse() {
        let prev = null;
        let current = this.head;
        let next = null;

        while (current) {
            next = current.next; // 保存下一个节点的引用
            current.next = prev; // 当前节点指向前一个节点
            prev = current;      // 更新前一个节点
            current = next;      // 更新当前节点
        }
        this.head = prev; // 新的头节点是原链表的尾节点
    }
    // 打印链表元素
    print() {
        let current = this.head;
        while (current) {
            console.log(current.data);
            current = current.next;
        }
    }
  }
  // 创建一个链表
  const linkedList = new LinkedList();
  // 向链表中添加一些节点
  linkedList.append(1);
  linkedList.append(2);
  linkedList.append(3);
  linkedList.append(4);
  linkedList.append(5);
  console.log("原链表:");
  linkedList.print(); // 输出原链表: 1, 2, 3, 4, 5
  // 反转链表
  linkedList.reverse();
  console.log("反转后的链表:");
  linkedList.print(); // 输出反转后的链表: 5, 4, 3, 2, 1

  ```

## 编程实践题

【注意】

1. 不要使用现有 UI 组件，旨在考察 css 样式应用和实现过程
2. 无设计图，可自由发挥；尽量朝着好的 UX 和 UI 方向优化，旨在考察 UI 和 UX 的敏感程度
3. 组件名称。变量。注释换行等，请符合代码规范
4. 使用到其他工具，eslint， husky， prettier， github action, docker 等可自由发挥。

【问题】

- 请实现一个 Vue 组件，包含一个输入框和一个按钮，点击按钮后将输入框中的内容添加到一个列表中。
- 请实现一个 Vue 组件，包含一个输入框和一个表格，输入框中输入关键字后，表格中的数据会根据关键字进行筛选。
- 请实现一个 Vue 组件，包含一个轮播图和一个分页器，轮播图中有多张图片，分页器可以切换轮播图中的图片。

- 请实现一个 Vue 组件，包含一个按钮和一个 modal 弹框， 点击按钮出现 modal 框，点击其他部分 modal 框消失。
  - 在该组件基础上，使其支持自定义 modal 框内容，头部和底部。
- 将上述组件组织在一个 project 内

## 使用

1. fork 本 repo.
2. 使用应聘名称作为 branch eg . feature/xxxxxx
3. 完成上述要求，并提交。
4. 创建 PR 到本 repo 的 develop 分支，
5. 如有任何问题欢迎 Issue 提问
6. 编程实践题部分，使用该 repo [fe-test](https://github.com/ZhaoKunLong/fe-test) 进行
